%!TEX encoding = UTF-8 Unicode
%!TEX root = ../lect-week06.tex

%%%
\ifkompendium\else


\Subsection{Case-klasser och likhet}



\begin{Slide}{Varför case-klass?}
Med case-klasser får du mycket ''godis på köpet'':
\begin{itemize}
\item Skapa \Emph{oföränderlig datastruktur} med få kodrader.
\item Klassparametrar blir automatiskt publika \code{val}-attribut (inte \texttt{private[this]} som i vanliga klasser).
\item Du får en automatisk \Emph{toString} som ger klassens namn och värdet av alla \code{val}-attribut som ges av klassparametrarna.
\item Du slipper skriva \code{new} eftersom du får ett automatiskt kompanjonsobjekt med en fabriksmetod \code{apply} för indirekt instansiering där alla klassparametrarnas \code{val}-attribut initialiseras.
\item Metoden \code{==} ger \Emph{strukturlikhet} (och inte referenslikhet).
\end{itemize}
\end{Slide}



\begin{Slide}{Likhet och case-klasser}
Metoden \code{equals} är i case-klasser automatiskt överskuggad så att metoden \code{==} ger test av strukturlikhet. 
\begin{REPL}
scala> case class Gurka(vikt: Int)

scala> val g1 = Gurka(42)
g1: Gurka = Gurka(42)

scala> val g2 = Gurka(42)
g2: Gurka = Gurka(42)

scala> g1 eq g2          // olika instanser
res0: Boolean = false

scala> g1 == g2          // samma innehåll!
res1: Boolean = true
\end{REPL}
\end{Slide}



\begin{Slide}{Sammanfattning case-klass-godis}
Minneschecklista med ''godis'' i \code{case}-klasser så här långt:
\begin{enumerate}
\item klassparametrar blir \code{val}-attribut 
\item najs toString
\item slipper skriva \code{new}
\item == ger strukturlikhet
\pause~\\...
\end{enumerate}

\vspace{3em}Men vi har inte sett allt godis än... \\Vecka 8: Mönstermatchning.
\end{Slide}



\fi